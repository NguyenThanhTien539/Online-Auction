------------------------------- CREATE TABLES -------------------------------



------------------ Function to remove accents from text
create or replace function remove_accents(text)
returns text as $$
select translate(lower($1),
  'àáãảạăằắẳẵặâầấẩẫậèéẻẽẹêềếểễệđùúủũụưừứửữựòóỏõọôồốổỗộơờớởỡợìíỉĩịäëïîöüûñçýỳỹỵỷ',
  'aaaaaaaaaaaaaaaaaeeeeeeeeeeeduuuuuuuuuuuoooooooooooooooooiiiiiaeiiouuncyyyyy'
);
$$ language sql immutable;






---------------------- Users Table
create table public.users (
  user_id serial not null,
  username character varying(50) not null,
  full_name character varying(50) not null,
  email character varying(50) not null,
  password character varying(100) null,
  address character varying(100) null,
  role character varying(10) null default 'user'::character varying,
  date_of_birth date null,
  rating double precision null default 0.0,
  rating_count integer null default 0,
  created_at timestamp with time zone null default now(),
  avatar text null,
  status text not null default 'active'::text,
  constraint users_pkey primary key (user_id),
  constraint users_email_key unique (email),
  constraint users_status_check check (
    (
      status = any (array['active'::text, 'inactive'::text])
    )
  )
) TABLESPACE pg_default;


---------------------- Categories Table
create table public.categories (
  id serial not null,
  name character varying(50) not null,
  parent_id integer null,
  status character varying(10) not null default 'active'::character varying,
  deleted boolean not null default false,
  description character varying(1000) null,
  created_by integer null,
  updated_by integer null,
  created_at timestamp without time zone not null default now(),
  updated_at timestamp without time zone not null default now(),
  slug character varying(100) null,
  cat_image text null,
  constraint categories_pkey primary key (id),
  constraint categories_slug_key unique (slug),
  constraint fk_categories_parent foreign KEY (parent_id) references categories (id)
) TABLESPACE pg_default;



---------------------- Products Table
create table public.products (
  product_id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  product_name character varying null,
  seller_id bigint not null,
  step_price double precision null,
  start_price double precision null,
  current_price double precision null,
  buy_now_price double precision null,
  price_owner_id bigint null,
  bid_turns bigint null default '0'::bigint,
  start_time timestamp with time zone null,
  end_time timestamp with time zone null,
  cat2_id bigint null,
  is_removed boolean null default false,
  description text null,
  product_images character varying[] null,
  auto_extended boolean null default false,
  edited_at timestamp with time zone null,
  fts tsvector GENERATED ALWAYS as (
    to_tsvector(
      'english'::regconfig,
      remove_accents ((product_name)::text)
    )
  ) STORED null,
  auction_end_email_sent boolean null default false,
  constraint products_pkey primary key (product_id),
  constraint products_cat2_id_fkey foreign KEY (cat2_id) references categories (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_products_auction_end_email on public.products using btree (end_time, auction_end_email_sent) TABLESPACE pg_default
where
  (auction_end_email_sent = false);

create index IF not exists products_fts on public.products using gin (fts) TABLESPACE pg_default;













-------- Bidding Ban User Table
create table public.bidding_ban_user (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  product_id bigint null,
  user_id integer null,
  reason text null,
  constraint bidding_ban_user_pkey primary key (id),
  constraint bidding_ban_user_product_id_fkey foreign KEY (product_id) references products (product_id),
  constraint bidding_ban_user_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;


---------------- Bidding History Table
create table public.bidding_history (
  bidding_id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  product_id bigint not null,
  user_id integer not null,
  max_price double precision null,
  product_price double precision null,
  price_owner_id bigint null,
  status text null,
  constraint bidding_history_pkey primary key (bidding_id),
  constraint bidding_history_product_id_fkey foreign KEY (product_id) references products (product_id) on delete CASCADE,
  constraint bidding_history_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;




--------------------- Extend Bidding Time Table
create table public.extend_bidding_time (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  extend_time bigint null default '10'::bigint,
  threshold_time bigint null default '5'::bigint,
  constraint extendBiddingTime_pkey primary key (id)
) TABLESPACE pg_default;






----------------------- Love Products Table
create table public.love_products (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  user_id integer not null,
  product_id bigint not null,
  constraint love_products_pkey primary key (id),
  constraint love_products_product_id_fkey foreign KEY (product_id) references products (product_id) on delete CASCADE,
  constraint love_products_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;



----------------------- Orders Table
create table public.orders (
  order_id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  user_id integer not null,
  product_id bigint null,
  order_status text null default 'pending'::text,
  shipping_address text null,
  phone_number text null,
  payment_proof_image_url text null,
  shipping_label_image_url text null,
  constraint orders_pkey primary key (order_id),
  constraint orders_product_id_fkey foreign KEY (product_id) references products (product_id),
  constraint orders_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;






----------------------- OTP Codes Table
create table public.otp_codes (
  id serial not null,
  email character varying(255) not null,
  otp character varying(10) not null,
  otp_expiry timestamp without time zone null default (now() + '00:02:00'::interval),
  created_at timestamp without time zone null default now(),
  constraint otp_codes_pkey primary key (id),
  constraint otp_codes_email_key unique (email)
) TABLESPACE pg_default;



----------------------- Product Questions Table
create table public.product_questions (
  question_id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  product_id bigint not null,
  user_id integer not null,
  content text null,
  question_parent_id bigint null,
  constraint product_questions_pkey primary key (question_id),
  constraint product_questions_product_id_fkey foreign KEY (product_id) references products (product_id) on delete CASCADE,
  constraint product_questions_question_parent_id_fkey foreign KEY (question_parent_id) references product_questions (question_id),
  constraint product_questions_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;





------------------------- Upgrade to Sellers Table
create table public.upgrade_to_sellers (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  user_id integer not null,
  expiry_time timestamp with time zone null,
  reason text null,
  status text null default 'pending'::text,
  constraint upgrade_to_sellers_pkey primary key (id),
  constraint upgrade_to_sellers_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;





------------------------- User Blacklist Table
create table public.user_blacklist (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  user_id integer not null,
  constraint user_blacklist_pkey primary key (id),
  constraint user_blacklist_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;


--------------------------------- User Rating Table
create table public.user_rating (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  user_id integer not null,
  rater_id integer not null,
  score bigint not null,
  comment text null,
  constraint user_rating_pkey primary key (id),
  constraint user_rating_rater_id_fkey foreign KEY (rater_id) references users (user_id),
  constraint user_rating_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;





------------------------- Function to Ban Auction User ------------------------
CREATE OR REPLACE FUNCTION ban_auction_user(
    p_product_id BIGINT,
    p_user_id BIGINT,
    p_reason TEXT
)
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
    v_step_price DOUBLE PRECISION;
    v_starting_price DOUBLE PRECISION;
    v_new_price DOUBLE PRECISION;
    v_new_winner_id BIGINT;
    v_top_bid RECORD;
    v_second_bid RECORD;
    v_bid_count INTEGER;
    v_distinct_bidders INTEGER;
    v_seller_id BIGINT;
    v_user_max_price DOUBLE PRECISION;
    v_result JSON;
BEGIN
    -- ============================================================================
    -- STEP 1: Ban the user - Insert into bidding_ban_user table
    -- ============================================================================
    INSERT INTO bidding_ban_user (product_id, user_id, reason, created_at)
    VALUES (p_product_id, p_user_id, p_reason, NOW());

    RAISE NOTICE 'User % has been banned from product %', p_user_id, p_product_id;

    -- ============================================================================
    -- STEP 2: Invalidate all bids from the banned user
    -- ============================================================================
    UPDATE bidding_history
    SET status = 'BANNED'
    WHERE product_id = p_product_id 
      AND user_id = p_user_id
      AND (status IS NULL OR status = 'VALID');

    RAISE NOTICE 'All bids from user % on product % have been marked as BANNED', p_user_id, p_product_id;

    -- ============================================================================
    -- STEP 3: Get product information (step_price, starting_price)
    -- ============================================================================
    SELECT step_price, start_price, seller_id
    INTO v_step_price, v_starting_price, v_seller_id
    FROM products
    WHERE product_id = p_product_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Product % not found', p_product_id;
    END IF;

    -- ============================================================================
    -- STEP 4: Count remaining valid bidders
    -- ============================================================================
    SELECT COUNT(DISTINCT user_id)
    INTO v_distinct_bidders
    FROM bidding_history
    WHERE product_id = p_product_id
      AND (status IS NULL OR status = 'VALID');

    RAISE NOTICE 'Remaining valid bidders: %', v_distinct_bidders;

    -- ============================================================================
    -- STEP 5: Recalculate winner and price based on remaining valid bids
    -- ============================================================================

    IF v_distinct_bidders = 0 THEN
        -- ========================================================================
        -- SCENARIO C: No valid bidders remain
        -- Reset to starting price, no winner (price_owner_id = NULL)
        -- History record will use seller_id as user_id but price_owner_id stays NULL
        -- ========================================================================
        v_new_price := v_starting_price;
        v_new_winner_id := NULL;  -- No winner, price_owner_id will be NULL
        
        RAISE NOTICE 'SCENARIO C: No bidders remain. Reset to starting price: %, winner: NULL', v_new_price;

    ELSIF v_distinct_bidders = 1 THEN
        -- ========================================================================
        -- SCENARIO B: Only one bidder remains
        -- Winner = highest bidder, Price = starting_price (no competition)
        -- ========================================================================
        SELECT user_id, max_price
        INTO v_top_bid
        FROM bidding_history
        WHERE product_id = p_product_id
          AND (status IS NULL OR status = 'VALID')
        ORDER BY max_price DESC, created_at ASC
        LIMIT 1;

        v_new_winner_id := v_top_bid.user_id;
        v_new_price := v_starting_price;

        RAISE NOTICE 'SCENARIO B: Only 1 bidder (%) remains. Price reset to starting price: %', 
                     v_new_winner_id, v_new_price;

    ELSE
        -- ========================================================================
        -- SCENARIO A: Multiple bidders remain (at least 2)
        -- Winner = highest bidder
        -- Price = 2nd highest bid + step_price (capped at winner's max bid)
        -- ========================================================================
        
        -- Get the TOP 2 distinct bids (by user)
        -- We need the highest bid from each user, then take the top 2
        WITH ranked_bids AS (
            SELECT DISTINCT ON (user_id)
                user_id,
                max_price,
                created_at
            FROM bidding_history
            WHERE product_id = p_product_id
              AND (status IS NULL OR status = 'VALID')
            ORDER BY user_id, max_price DESC, created_at ASC
        )
        SELECT user_id, max_price, created_at
        INTO v_top_bid
        FROM ranked_bids
        ORDER BY max_price DESC, created_at ASC
        LIMIT 1;

        -- Get second highest bid
        WITH ranked_bids AS (
            SELECT DISTINCT ON (user_id)
                user_id,
                max_price,
                created_at
            FROM bidding_history
            WHERE product_id = p_product_id
              AND (status IS NULL OR status = 'VALID')
              AND user_id != v_top_bid.user_id  -- Exclude the winner
            ORDER BY user_id, max_price DESC, created_at ASC
        )
        SELECT user_id, max_price, created_at
        INTO v_second_bid
        FROM ranked_bids
        ORDER BY max_price DESC, created_at ASC
        LIMIT 1;

        v_new_winner_id := v_top_bid.user_id;

        -- Calculate new price: 2nd bid + step_price, but not exceeding winner's max bid
        IF v_second_bid.max_price + v_step_price > v_top_bid.max_price THEN
            v_new_price := v_top_bid.max_price;
        ELSE
            v_new_price := v_second_bid.max_price + v_step_price;
        END IF;

        RAISE NOTICE 'SCENARIO A: Winner=%, Top bid=%, Second bid=%, New price=%', 
                     v_new_winner_id, v_top_bid.max_price, v_second_bid.max_price, v_new_price;
    END IF;

    -- ============================================================================
    -- STEP 6: Update the products table with new winner and price
    -- ============================================================================
    UPDATE products
    SET current_price = v_new_price,
        price_owner_id = v_new_winner_id
    WHERE product_id = p_product_id;

    RAISE NOTICE 'Product % updated: new_price=%, new_winner=%', 
                 p_product_id, v_new_price, v_new_winner_id;

    -- ============================================================================
    -- STEP 6.5: Get the correct max_price for the history record
    -- If winner exists: get their latest max_price from bidding_history
    -- If no winner (seller): use starting_price
    -- ============================================================================
    IF v_new_winner_id IS NOT NULL THEN
        -- Get the latest max_price for the winner from their bidding history
        SELECT max_price
        INTO v_user_max_price
        FROM bidding_history
        WHERE product_id = p_product_id
          AND user_id = v_new_winner_id
          AND (status IS NULL OR status = 'VALID')
        ORDER BY created_at DESC
        LIMIT 1;
        
        -- If not found (shouldn't happen), default to v_new_price
        v_user_max_price := COALESCE(v_user_max_price, v_new_price);
        
        RAISE NOTICE 'Winner % max_price retrieved: %', v_new_winner_id, v_user_max_price;
    ELSE
        -- No winner, seller takes over, use starting price
        v_user_max_price := v_starting_price;
        
        RAISE NOTICE 'No winner, using starting_price as max_price: %', v_user_max_price;
    END IF;

    -- ============================================================================
    -- STEP 7: Log the system correction in bidding_history
    -- For SCENARIO C (no winner): user_id = seller_id, price_owner_id = NULL
    -- For other scenarios: user_id = winner_id, price_owner_id = winner_id
    -- ============================================================================
    INSERT INTO bidding_history (
        user_id,
        product_id,
        max_price,
        product_price,
        price_owner_id,
        status,
        created_at
    )
    VALUES (
        COALESCE(v_new_winner_id, v_seller_id),  -- Use seller_id if no winner
        p_product_id,
        v_user_max_price,  -- Use the retrieved max_price from history
        v_new_price,
        v_new_winner_id,  -- NULL if no winner, winner_id otherwise
        null,
        NOW()
    );

    ----------- Update bid_turns in products table -----------
    UPDATE products
    SET bid_turns = bid_turns + 1
    WHERE product_id = p_product_id;

    RAISE NOTICE 'System correction logged in bidding_history';

    -- ============================================================================
    -- STEP 8: Return success result
    -- ============================================================================
    v_result := json_build_object(
        'status', 'success',
        'message', 'User banned and price recalculated successfully',
        'banned_user_id', p_user_id,
        'product_id', p_product_id,
        'new_winner_id', v_new_winner_id,
        'new_price', v_new_price,
        'remaining_bidders', v_distinct_bidders
    );

    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        -- Rollback is automatic in PostgreSQL for failed functions
        RAISE EXCEPTION 'Error in ban_auction_user: % - %', SQLERRM, SQLSTATE;
        
        RETURN json_build_object(
            'status', 'error',
            'message', SQLERRM
        );
END;
$$;




